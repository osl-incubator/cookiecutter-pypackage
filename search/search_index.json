{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SciCookie","text":"<p>SciCookie is a template developed by Open Science Labs that creates projects from project templates and is based on Cookieninja A Cookiecutter Fork command-line utility. It serves as a boilerplate which can be used by beginners as well as full fledged developers to simplify the project creation process and save considerable amount of time. Cookieninja enables projects with an initial layout that includes recommended tools, workflows, and project structure.</p> <p>Cookieninja also offers other features that can enhance the workflow of the development process. Features such as automatic documentation generation, automated testing, and project-specific configuration are part of this. Overall, Cookieninja is an efficient tool that gives users the ability to effortlessly create consistent, high-quality projects.</p> <p>Open Science Labs Scientific Python cookiecutter template is primarily based on the PyOpenSci recommendations who is actively conducting research to determine the tools, libraries, best practices, and workflows utilized by significant scientific Python groups. As a result, this template offers to authors a starting point for their project that adheres with industry standards and can be adjusted to meet particular project requirements.</p> <p>Cookieninja template for a Python package.</p> <ul> <li>GitHub repo: https://github.com/osl-incubator/scicookie/</li> <li>Software License: BSD license</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Allows package slug (use <code>_</code> instead of <code>-</code>)</li> <li>Licenses supported: MIT, BSD 3 Clause, ISC License, Apache Software License   2.0, and GPL 3</li> <li>Documentation engines: mkdocs, sphinx, jupyter-boook</li> <li>Test library: pytest, hypothesis</li> <li>Auto format code tool: black</li> <li>Initial integration with git</li> <li>Support to conda (as base environment) and poetry as packaging and dependency   management</li> <li>Support to pre-commit</li> <li>CI with github actions</li> <li>Release workflow with semantic release and github actions</li> <li>Flexible build system selection: Choose between popular build systems like   Poetry, Flit,   meson-python,   Setuptools,   PDM, Hatch,   Maturin,   scikit-build-core or   setuptools + pybind11 based on   your preference.</li> <li>The structure of the project can use the src layout or flat layout. The   \u201csrc layout\u201d moving the code that is intended to be importable into a   subdirectory. This subdirectory is typically named src. \"Flat layout\" refers   to organising a project's files in a folder or repository so that the various   configuration files and import packages are all in the top-level directory.   You can read about their differences at   https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/</li> <li>Finding common security problems in Python code using   bandit</li> <li>Offers the option to use pydocstyle   for checking compliance with Python documentation conventions.</li> <li>Finds unused code in Python programs using   vulture.</li> <li>To automatically detect overly complex code based on cyclomatic complexity,   the template gives you the option to use the   McCabe library, which is included via   flake8.</li> <li>Provides the option to add initial files that allow you to run and orchestrate   containers using Docker or   Podman in your project.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install the latest Cookieninja if you haven't installed it yet (this requires Cookieninja 1.0.0):</p> <pre><code>pip install scicookie\n</code></pre> <p>Go to a desired folder to create your new project, for example:</p> <pre><code>cd ~/dev/my-python-projects\n</code></pre> <p>Generate a Python package project:</p> <pre><code>scicookie\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>For testing your changes locally, you can run:</p> <pre><code>makim tests.lint\nmakim tests.unittest\nmakim tests.smoke\n</code></pre>"},{"location":"#maintainers","title":"Maintainers","text":"<ul> <li>Anavelyz Perez - @Anavelyz</li> <li>Ever Vino - @EverVino</li> <li>Ivan Ogasawara - @xmnlab</li> <li>Saransh Chopra - @Saransh-cpp</li> <li>Yurely Camacho - @YurelyCamacho</li> <li>Ankit Kumar - @ayeankit</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Your contributions are valued and play a significant role in the continuous improvement of SciCookie. We welcome contributions of all forms and acknowledge all efforts.</p>"},{"location":"contributing/#how-you-can-contribute","title":"How You Can Contribute","text":"<p>Contributions can be made in various ways, outlined below:</p>"},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>If you encounter a bug in SciCookie, please report it via our GitHub issues page at: https://github.com/osl-incubator/scicookie/issues.</p> <p>When reporting a bug, kindly include the following information to aid in the issue's resolution:</p> <ul> <li>The name and version of your operating system.</li> <li>Any relevant details about your setup that might assist in diagnosing the   issue.</li> <li>A step-by-step guide to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>You can contribute by fixing bugs identified in the GitHub issues. Issues tagged with both \"bug\" and \"help wanted\" are available for anyone to work on.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Feature development is another way to contribute. Review the GitHub issues for requested features. Issues labeled with \"enhancement\" and \"help wanted\" are open for implementation.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>There's always a need for more documentation for SciCookie. This could be through enhancing the official documentation, contributing to docstrings, or sharing knowledge via blog posts, articles, and other media.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>Feedback is crucial for project improvement. To submit feedback or propose a feature:</p> <ul> <li>File an issue at   https://github.com/osl-incubator/scicookie/issues.</li> <li>For feature proposals, please provide a detailed explanation of how the   feature would function, aim for a narrow scope to facilitate easier   implementation, and remember, SciCookie is a volunteer-driven project, and   we welcome contributions.</li> </ul>"},{"location":"contributing/#requirements","title":"Requirements","text":"<p>Before you begin contributing to the SciCookie project, there are several technical prerequisites and best practices you should be familiar with. This section outlines the key requirements to ensure a smooth and productive contribution process.</p>"},{"location":"contributing/#conda-environment","title":"Conda Environment","text":"<p>Conda is a versatile tool that provides package, dependency, and environment management for various programming languages. In the SciCookie project, we leverage Conda to manage virtual environments and package dependencies effectively.</p> <ul> <li>Environment Setup: We strongly advise using a Conda environment while   working with SciCookie. If Conda is not installed on your system, you can   download it from Miniforge. For an   introductory overview of Conda, consider watching this   Conda Basics video.</li> <li>Best Practices: Avoid installing packages in the base Conda environment.   Always create and activate a new environment for each project to prevent   dependency conflicts and ensure a clean workspace.</li> </ul>"},{"location":"contributing/#git","title":"Git","text":"<p>Our collaborative efforts are facilitated through Git and GitHub. Understanding the fundamentals of Git is crucial for effective participation.</p> <ul> <li>Learning Resources: If you're new to Git, we recommend starting with the   Software Carpentry Git Lesson,   which covers essential Git concepts and workflows.</li> <li>Quick Reference: For a concise summary of common Git commands, refer to   this   Git Cheat Sheet   provided by GitHub.</li> <li>Configuration Tips:</li> <li>To streamline your workflow, configure Git to use <code>rebase</code> by default for     pulling changes with <code>git config --global pull.rebase true</code>.</li> <li>Familiarize yourself with the <code>git rebase</code> command for updating branches     from a remote repository. Although more complex, it is preferred over the     default merge commit strategy. For an in-depth explanation, visit     Atlassian's guide on merging vs. rebasing.</li> <li>Workflow: The standard open-source development workflow includes forking a   repository, cloning the fork locally, and configuring an <code>upstream</code> remote for   the original repository. Detailed instructions can be found in   GitHub's guide to configuring a remote for a fork.</li> </ul>"},{"location":"contributing/#python","title":"Python","text":"<p>Familiarity with Python and adherence to best practices is important for contributing to SciCookie.</p> <ul> <li>Style Guide: Follow the PEP 8 style guide for Python code, available at   PEP8.</li> <li>Best Practices: pyOpenSci offers a comprehensive guide for writing Python   packages, which can be found   here.</li> <li>Advanced Learning: To deepen your understanding of Python and general   programming concepts, consider enrolling in the   Design of Computer Programs   course on Udacity. Though challenging and based on Python 2, it provides   valuable insights into advanced Python usage and computer programming   principles.</li> </ul>"},{"location":"contributing/#how-to-get-support","title":"How to Get Support","text":"<p>Should you require assistance, please join our community on the Open Science Labs Discord server at https://opensciencelabs.org/discord. Here, you can participate in the incubator program and ask questions about SciCookie in its dedicated channel. You are also welcome to explore and join other groups that align with your interests.</p>"},{"location":"contributing/#setting-up-for-local-development","title":"Setting Up for Local Development","text":"<p>To contribute to <code>scicookie</code>, follow these steps to set up your development environment:</p> <ol> <li> <p>Fork the Repository: Begin by forking the <code>scicookie</code> repository on    GitHub to your own account.</p> </li> <li> <p>Clone Your Fork Locally: Clone the forked repository to your local    machine and navigate into the project directory.</p> </li> </ol> <pre><code>$ git clone git@github.com:your_username/scicookie.git\n$ cd scicookie\n</code></pre> <ol> <li>Install Dependencies: Use <code>mamba</code> to create a Conda environment and    <code>poetry</code> for managing Python dependencies.</li> </ol> <pre><code>$ mamba env create --file conda/dev.yaml --force\n$ poetry config virtualenvs.create false\n$ poetry install\n</code></pre> <ol> <li>Create a Development Branch: Make a dedicated branch for your bugfix or    feature.</li> </ol> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <ol> <li> <p>Make Changes Locally: You are now ready to implement your changes or    improvements.</p> </li> <li> <p>Install and Use Pre-commit Hooks: <code>scicookie</code> utilizes <code>pre-commit</code> hooks    to ensure code quality. Install them locally and they will automatically run    on each commit.</p> </li> </ol> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre> <p>To bypass the hooks temporarily, use <code>git commit</code> with <code>--no-verify</code>.</p> <ol> <li>Run Smoke Tests: Quickly validate the functionality of your changes with    smoke tests.</li> </ol> <pre><code>$ makim tests.smoke\n</code></pre> <p>Always complement smoke tests with thorough unit testing to ensure code    integrity.</p> <ol> <li>Unit Testing with <code>pytest</code>: <code>scicookie</code> leverages <code>pytest</code> for unit    testing, along with <code>pytest-cov</code> for coverage analysis. Run unit tests using:</li> </ol> <pre><code>$ python -m pytest\n</code></pre> <p>or</p> <pre><code>$ makim tests.unittest\n</code></pre> <ol> <li>Commit and Push Changes: Stage, commit, and push your changes to GitHub.    After setting the upstream branch once, subsequent pushes only require    <code>git push</code>.</li> </ol> <pre><code>$ git add .\n$ git commit -m \"Detailed description of your changes.\"\n$ git push --set-upstream origin &lt;branch name&gt;\n</code></pre> <ol> <li>Submit a Pull Request: Once your changes are pushed, go to the GitHub     website to submit a pull request for review.</li> </ol>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>The SciCookie project utilizes <code>semantic-release</code> to automate the release process, basing new releases on the content of commit messages.</p>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p><code>semantic-release</code> analyzes commit messages to assess the impact of changes made to the codebase. Adhering to a standardized commit message format allows <code>semantic-release</code> to automatically determine the next semantic version number, generate a comprehensive changelog, and publish the release.</p> <p>While <code>semantic-release</code> defaults to the Angular Commit Message Conventions, SciCookie adopts the \"Conventional Commits\" standard (https://www.conventionalcommits.org/en/v1.0.0/). This standard facilitates more detailed commit messages, especially for \"breaking changes\".</p> <p>Given the project's use of the <code>squash and merge</code> strategy for merging pull requests, it is crucial to format the PR title according to the commit message standards.</p> <p>To aid contributors in crafting compliant commit messages, tools like commitizen and commitlint are recommended. These tools help ensure that commit messages adhere to the required format.</p> <p>The following table illustrates how different commit messages correspond to the type of release generated by <code>semantic-release</code>, according to its default configuration:</p> Commit Message Example Release Type <code>fix(pencil): stop graphite breaking when too much pressure</code> Patch Release <code>feat(pencil): add 'graphiteWidth' option</code> Minor Release <code>perf(pencil): optimize 'graphiteWidth' calculation</code> Patch Release <code>fix(pencil)!: 'graphiteWidth' option removed</code> Major Release <p>Note: Within the Conventional Commits standard, appending <code>!</code> to the message prefix indicates a breaking change.</p> <p>For more details on the commit message format used by <code>semantic-release</code>, visit the semantic-release documentation.</p>"},{"location":"guide/","title":"SciCookie user guide","text":"<p>SciCookie is a package that offers a template for your Python project. The team has created this guide to help you understand every option and its functionality.</p> <p>The structure of the guide is as follows:</p> <ul> <li>SciCookie user guide</li> <li>Notes about the text-based user interface (TUI)</li> <li>The author of project</li> <li>Information about the project</li> <li>Project settings<ul> <li>Project layout</li> <li>Build system</li> <li>Command-line interfaces (CLIs)</li> <li>Documentation engine</li> </ul> </li> <li>Project tools<ul> <li>Virtual environment</li> <li>Code formatter</li> <li>Code security vulnerabilities</li> <li>Code coverage testing</li> <li>Code style and logic (code quality)</li> <li>Testing framework</li> <li>Static analysis of shell scripts</li> <li>Pre-commit verification</li> </ul> </li> <li>Integration with DevOps tools</li> <li>Automation tools</li> <li>Project team<ul> <li>Code of conduct</li> <li>Governance document</li> <li>Roadmap document</li> </ul> </li> <li>Version control</li> </ul>"},{"location":"guide/#notes-about-the-text-based-user-interface-tui","title":"Notes about the text-based user interface (TUI)","text":"<p>A TUI, or text-based user interface, is a type of user interface that uses text and keyboard input to display and interact with information on a computer screen.</p> <p>When you run the <code>scicookie</code> command in your terminal, a text-based user interface (TUI) is displayed where you can provide information about the author or the project itself. You can also choose from several options that are presented to you, with default values in all cases. To switch from one option to another, simply press \"Enter\".</p> <p>In some cases, you may see a list of sub-options within a main option. Use the arrow keys to move up and down between the sub-options and the <code>&gt;</code> symbol will appear before the sub-option you have selected. Make sure you press \"Enter\" to confirm your selection when the required sub-option has been selected.</p> <p>You will also see a list of options for the project tools, this is presented in the following way:</p> <pre><code> &gt; [ ] bandit\n   [ ] black\n   [ ] conda\n   [ ] coverage\n   [ ] flake8\n   [ ] ruff\n   [ ] isort\n   [ ] make\n   [ ] makim\n   [ ] mccabe\n   [ ] mypy\n   [ ] pre-commit\n   [ ] prettier\n   [ ] pydocstyle\n   [ ] pytest\n   [ ] hypothesis\n   [ ] shellcheck\n   [ ] vulture\n</code></pre> <p>Use the right arrow key to select the tools you want, and use the up and down arrow keys to navigate through the list. If you accidentally select an option you don't want, simply use the left arrow key to deselect it.</p> <p>The following is a description of the options in the TUI.</p>"},{"location":"guide/#the-author-of-project","title":"The author of project","text":"<p>With SciCookie, you can easily add information about the author of the project by filling in the author_full_name and author_email fields, which refer to the name and email address of the person or organization that authored the project.</p> <p>The default values give you an idea of what you can enter in these fields. This information can be found in the <code>pyproject.toml</code> file, the documentation and the github configuration, to name a few.</p>"},{"location":"guide/#information-about-the-project","title":"Information about the project","text":"<p>Every project needs specific information for both development and maintenance. SciCookie allows you to customise this information, which is displayed in several parts, such as: documentation, git, configuration files, the project repository, PyPI (Python Package Index) and more.</p> <p>Below are the fields within the TUI that relate to project information:</p> <ul> <li> <p>project_name: This is the name of the project according to the creator,   i.e. the main title of the project, as shown on the README page, for example.</p> </li> <li> <p>project_slug: This is the name of the project, probably abbreviated using   characters suitable for naming a Python package. Also, it is the name used for   the repository and the one registered with PyPI. In simpler terms, it refers   to the name of the python package to use when you want to install it. In   SciCookie, this name can include hyphens (-) or underscores (_).</p> </li> <li> <p>package_slug: This refers to the name used when importing the package.   This name allows the usage of (_) instead of (-), which is a particularity of   SciCookie. Consequently, the project_slug and the package_slug can match   (when both use underscores).</p> </li> <li> <p>project_version: This is where you can enter the version of your python   package, most Python packages use semantic versioning. SciCookie offers you to   manage the release workflow with semantic release and github actions. For more   information on releasing and versioning, please click   here.</p> </li> <li> <p>project_url: This is the URL of the project's website used for example, in   the documentation and the <code>pyproject.toml</code> file. On this website you will   generally find information about the project, the team, events, the blog, etc.   It is used to promote the project.</p> </li> <li> <p>project_license: This field allows you to specify the license of the   project. In SciCookie you can find and choose from the following well-known   open source software licenses: MIT, BSD 3 Clauses, ISC license, Apache   Software License 2.0 and GNU General Public License v3.</p> </li> <li> <p><code>MIT</code> option: is a free software license that allows users to use,     modify and redistribute the software without significant restrictions. It is     a permissive license that allows users to do whatever they want with the     software, as long as a copy of the license is included and the original     authorship of the software is acknowledged. In SciCookie this is the license     type for default. If you want to know the content of this license, you can     visit https://mit-license.org/.</p> </li> <li> <p><code>BSD 3 Clauses</code> option: also allows users to use, modify and     redistribute the software without significant restrictions. It is similar to     the MIT license in terms of permissibility, but includes three additional     clauses that require you to include a copy of the license, acknowledge     original authorship of the software, and release the author from any     liability for damages. For more information, see     https://opensource.org/license/bsd-3-clause/.</p> </li> <li> <p><code>ISC license</code> option: is mainly used to distribute software related to     networking and Internet protocols. It is permissive and known to be short     and easy to understand. The author is not responsible for any damage or     problems caused by the use of the software. You can learn more about the     contents of this license at https://opensource.org/license/isc-license-txt/.</p> </li> <li> <p><code>Apache Software License 2.0</code> option: is a permissive license,     compatible with the GNU General Public License (GPL). It contains special     provisions relating to patents. It also requires that copyright and     attribution notices of the original authors be maintained on all copies of     the software, and allows users to make modifications to the software and     distribute modified versions. You can find out more about this license at     https://www.apache.org/licenses/LICENSE-2.0.</p> </li> <li> <p><code>GNU General Public License v3</code> option: includes the freedom to use,     modify and redistribute the software in accordance with the terms of the     license. Compared to previous versions, it addresses concerns about     interoperability with other systems and the use of technological protection     measures. If you modify or distribute the software under the GPL v3, you     must make the source code available to end users. More information is     available at https://www.gnu.org/licenses/gpl-3.0.html.</p> </li> </ul> <p>If you want to include another type of license according to the needs of your   project, you can do so by selecting the option <code>Other</code>.</p>"},{"location":"guide/#project-settings","title":"Project settings","text":"<p>Setting up some configurations in the project structure is important because it allows you to get an orderly workflow. With SciCookie you can configure elements such as project layout, build system, command-line interface and documentation engine. This can help streamline the development process by providing a consistent and standardized framework for the project.</p>"},{"location":"guide/#project-layout","title":"Project layout","text":"<p>The organization of your code is important, which is why at SciCookie we offer two alternatives: src and flat.</p> <ul> <li>src (Source) layout: The src layout is a common approach where the source   code files are organized within a dedicated \"src\" directory. This directory   serves as the root of the project's source code and typically contains   subdirectories that represent different modules or packages. Each module or   package within the \"src\" directory focuses on a specific aspect of the   project's functionality.</li> </ul> <p>For example, a project following the src structure might have the following   layout:</p> <pre><code>project_slug/\n\u251c\u2500 src/\n\u2502  \u2514\u2500 package_slug/\n\u2502     \u251c\u2500 __init__.py\n|     \u251c\u2500 __main__.py\n\u2502     \u251c\u2500 module.py\n\u2502     \u2514\u2500 ...\n\u251c\u2500 tests\n\u2502  \u2514\u2500 ...\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n</code></pre> <p>The src structure helps in organizing the codebase and makes it easier to   understand and maintain as the project grows larger. It also allows for better   separation of concerns and promotes modularity.</p> <ul> <li>Flat layout: The flat layout involves placing all the project's source   code files directly in the project's root directory without any   subdirectories. This means that all modules and packages are at the same level   and there is no explicit separation between different aspects of the project.</li> </ul> <p>Here's an example of a flat structure:</p> <pre><code>project_slug/\n\u2502 \u2514\u2500 package_slug/\n\u2502 __init__.py\n| __main__.py\n\u2502 module.py\n\u2502 ...\n\u251c\u2500 tests\n\u2502  \u2514\u2500 ...\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n</code></pre> <p>Because all source files are on the same level in this layout, they are easy   to find and access. However, as the project becomes larger and more complex,   it can become more difficult to maintain and navigate the codebase.</p> <p>The flat structure is simpler and may be suitable for smaller projects or   scripts where the codebase is relatively small and does not require extensive   organization or separation of concerns.</p> <p>Both src and flat layouts have their own advantages and disadvantages. The choice between them depends on your specific requirements and the complexity of your project, as well as your personal preferences and team conventions.</p> <p>If you want to find more information about it you can visit:</p> <ul> <li>Python Packaging User Guide \u00bb Discussions \u00bb src layout vs flat layout</li> <li>The source layout   in the book Python Packages by   Tomas Beuzen &amp;   Tiffany Timbers.</li> <li>Packaging a python library</li> </ul>"},{"location":"guide/#build-system","title":"Build system","text":"<p>There are several build system options available to development of Python packages. SciCookie support the following:</p> <ul> <li> <p>Poetry (default): It's a Python package   manager that streamlines dependency management and package distribution. It   provides a simple and intuitive syntax for defining project dependencies and   allows you to easily create and manage virtual environments for your projects.   With Poetry, you can easily install, update, and remove dependencies, and it   automatically handles conflicts and resolution between packages. Additionally,   Poetry provides a comprehensive toolset for packaging and publishing your   projects to PyPI, including support for building source distributions and   wheel packages, as well as generating and uploading documentation. Overall,   Poetry simplifies the development and distribution of Python projects, making   it a popular tool for many Python developers.</p> </li> <li> <p>Flit: It's a Python package and a lightweight tool   for creating and distributing Python packages. It automates the processes   involved in packaging and submitting a project to PyPI, and provides a   straightforward interface for managing a project's dependencies. With just a   few commands, you can use Flit to quickly create source distributions and   wheel packages and submit them to PyPI.</p> </li> <li> <p>meson-python:   It's a Python build backend built on top of the Meson build-system. It   enables you to use Meson for your Python packages. With meson-python, you can   easily define project dependencies, specify build options, generate   configuration files and build scripts, among other things. Meson-python is   primarily focused on improving speed and ease of use compared to other build   systems. It is designed to be fast and scalable, making it suitable for both   small and large projects.</p> </li> <li> <p>Setuptools: It's a package that   facilitates the distribution and installation of Python packages. Setuptools   provides a way to define metadata about your project, such as its name,   version, dependencies, and other details. It also provides functionality for   building and distributing packages, creating distribution archives, and   installing packages with their dependencies. \"It helps developers to easily   share reusable code (in the form of a library) and programs (e.g., CLI/GUI   tools implemented in Python), that can be installed with pip and uploaded to   PyPI.\"</p> </li> <li> <p>PDM: It's a modern Python package and dependency   manager supporting the latest PEP standards. But it is more than a package   manager. It boosts your development workflow in various aspects. It has very   powerful features, including easy and fast dependency resolution, especially   for large binary distributions, a PEP 517 compilation backend, PEP 621 project   metadata, a flexible and powerful plugin system. It also offers, among other   things, versatile user scripting, PyPI integration and version management.</p> </li> <li> <p>Hatch: It's a PEP 517/PEP 660 compatible build   backend used by Hatch, a modern, extensible Python project manager. It   provides a standardized build system with reproducible builds by default,   robust environment management with support for custom scripts, easy publishing   to PyPI or other indexes, version management, and configurable project   generation with sane defaults. Hatchling ensures that your builds are   reproducible, so you can be confident that they will always produce the same   results. It also helps you manage your Python environments, so you can be sure   that your projects have the correct dependencies.</p> </li> <li> <p>Maturin: It's build system   designed to create Python bindings from Rust projects. It allows Rust code to   be seamlessly integrated into Python applications, providing efficient builds   and cross-platform support for various Python versions. Maturin automates the   generation of Python modules that directly access Rust functions, harnessing   Rust's high performance and low-level capabilities within Python. Its   user-friendly interface and compatibility with setuptools and Cargo make it an   easy-to-use tool, offering developers a simple solution to combine the   strengths of Python and Rust within a unified project.</p> </li> <li> <p>scikit-build-core:   It's build system designed for Python packaging tool, serving as an enhanced   build system generator for CPython C extensions greatly improves package   management within the scientific Python ecosystem. It offers superior support   for diverse compilers, build systems, cross-compilation, and efficient   dependency locating with their associated build requirements. With its   capabilities, it facilitates cross-platform builds using CMake and effortless   integration with C/C++ libraries, making it a valuable asset for research   software engineers.</p> </li> <li> <p>setuptools + pybind11: It's   build system designed for C++ library that simplifies the creation of Python   bindings for C++ code, enabling easy integration of C++ functions and classes   into Python scripts. It acts as a bridge between the two languages, allowing   C++ algorithms and functionality to be directly called from Python as if they   were native Python modules. Pybind11's user-friendly syntax reduces   boilerplate code, making binding generation more straightforward, while   standard C++ build systems like CMake or Make facilitate the compilation of   projects using pybind11. Its efficiency, ease of use, and strong community   support have made it a popular choice for projects requiring seamless   interoperability between C++ and Python, ranging from scientific computing to   game development and automation. Staying up-to-date with the latest pybind11   documentation ensures the best practices are followed.</p> </li> </ul> <p>The idea behind the options in SciCookie is that you can choose from some of the most popular system compilers to suit your needs and preferences for developing Python packages. If you think we should add more options, you can submit your suggestion as a issue at https://github.com/osl-incubator/scicookie/issues/new/choose.</p>"},{"location":"guide/#command-line-interfaces-clis","title":"Command-line interfaces (CLIs)","text":"<p>A command line interface (CLI) is a type of text-based interface that allows the user to interact with a program or system using text commands rather than a graphical interface. It allows automation of tasks, access to advanced functions, and execution of complex commands with additional options.</p> <p>In addition to the operating system's native CLI, many programs and tools provide their own command line interfaces to facilitate interaction with their functionality. With SciCookie you have two CLI options: Click and Argparse.</p> <ul> <li> <p>Click: The Command Line   Interface Creation Kit is a Python package that allows you to create   beautiful command line interfaces in a composable way with as little code as   necessary. It is highly configurable, it aims to make the process of writing   command line tools quick and fun.</p> </li> <li> <p>Argparse: This is the   recommended command line parsing module in the Python standard library, and   provides an easy way to create command line interfaces with custom arguments   and options. It helps you parse user-supplied arguments and options, and   automatically generate help and usage messages.</p> </li> </ul> <p>If you do not want to include a CLI in your project, select <code>No command-line interface</code> (this is the default option).</p>"},{"location":"guide/#documentation-engine","title":"Documentation engine","text":"<p>One of the most important elements of a package (apart from the functionality of the code) is its documentation. If there is no quality documentation, it is very likely that people will not understand and therefore not use your package.</p> <p>To generate documentation for any project, tools have been developed that include functions such as content creation and editing, organization and classification of information, generation of output formats and integration with other development and project management tools, known as a documentation engine. This tool automates the creation of technical documentation for software projects by extracting information from source code, comments and project metadata.</p> <p>Depending on your taste and the needs of your project, you should choose the documentation engine that best suits your needs. SciCookie offers you three documentation engine options for your Python package: mkdocs, sphinx and jupyter-book.</p> <ul> <li> <p>mkdocs: is a fast, simple, and downright   gorgeous static site generator for creating project documentation.   Documentation source files are written in Markdown and configured with a   single <code>YAML</code> configuration file. It is designed to allow users to quickly   create clear and well-structured documentation without requiring advanced   programming skills. mkdocs can be easily integrated with version control   systems such as Git, supports a variety of predefined themes that allow you to   customise the visual appearance of your documentation. In SciCookie, so far,   we use the material theme to generate documentation with mkdocs.</p> </li> <li> <p>Sphinx: Sphinx makes it easy to   create intelligent and attractive documentation. It provides various output   formats such as HTML, LaTeX, ePub, Texinfo, manual pages, plain text. It also   generates automatic links to functions, classes, citations, glossary terms and   similar information. It allows the use of built-in extensions for automatic   code snippet checking, the inclusion of docstrings from Python modules, and   third-party extensions to include many more features. Sphinx uses the   reStructuredText markup language by default and can read MyST markdown   through third-party extensions.</p> </li> <li> <p>Jupyter Book: allows you   to create engaging, publication-quality books and documents from computational   content. Jupyter Book uses Jupyter notebooks as the basis for creating   interactive content. It allows you to structure and organise the notebooks   into a cohesive, navigable book. It also offers customisation options to adapt   the look and feel of the book to your needs and extensions to add additional   features. It can generate books in a variety of output formats, including   HTML, PDF and static web pages. It integrates well with version control   systems such as Git.</p> </li> </ul> <p>If you think we should add more options of documentation engines or themes, you can submit your suggestion as a issue at https://github.com/osl-incubator/scicookie/issues/new/choose.</p>"},{"location":"guide/#project-tools","title":"Project tools","text":"<p>SciCookie allows you to choose between several tools that can improve your project in different ways. Some of these tools can help you automate tasks, others allow you to format your code consistently, and others can help you find errors and vulnerabilities in your code, and much more.</p> <p>The tools are described below according to their functionality.</p>"},{"location":"guide/#virtual-environment","title":"Virtual environment","text":"<p>When working with Python, you should always have a virtual environment. This is an isolated space where you can install and run applications and software packages independently, without interfering with other environments or versions on your system. You control which package versions are installed and when they are updated. Virtual environments are disposable; you can delete and create as many as you like. In Python there are many tools to manage virtual environments, in SciCookie we offer you the option to use conda as your environment management system, which is a very popular option in the Python scientific community.</p> <ul> <li>Conda: is an open source package and   environment management system that runs on Windows, MacOS and Linux. It   quickly installs, runs and updates packages and their dependencies. It also   makes it easy to create, save, load and switch between environments on your   local machine, which is why we use conda as an option in SciCookie. If you   want an easy way to choose a specific version of Python, and if your project   relies on complex software libraries that are not easily installed with pip,   using conda is a good option. It is included in all versions of Anaconda and   Miniconda.</li> </ul> <p>If you select this option, a conda folder will appear in the project   directory, containing a dev.yaml file that you can use to manage the   development project's dependencies. If you do not select this option, a   requirements.txt will be added for you to manage with virtualenv.</p>"},{"location":"guide/#code-formatter","title":"Code formatter","text":"<p>A code formatter is a tool that automatically reformats code to conform to a set of coding standards, such as PEP 8 guidelines. It helps us ensure consistency in our code, saves time by automating the formatting process, reduces errors by enforcing coding standards, and facilitates collaboration by making it easier for multiple developers to work on the same code base. In the options of SciCookie, you will find: Black.</p> <ul> <li>Black: It is a popular code formatter tool   for Python that automatically formats code to conform to PEP 8 guidelines. It   provides a simple and opinionated way to format code, making it easy to use.   The advantages of using Black include its ability to ensure consistent   formatting, save time by automating the process, and reduce errors by   enforcing coding standards.</li> </ul> <p>You can read the black documentation if you want to know more about it.</p> <p>Using code formatters such as Black in your project helps ensure consistent and readable code, making it easier to maintain and collaborate on.</p>"},{"location":"guide/#code-security-vulnerabilities","title":"Code security vulnerabilities","text":"<p>The code security vulnerabilities are errors or weaknesses in code that can be exploited by attackers to gain unauthorized access, steal data, or cause damage to a system.</p> <p>To verify and prevent these vulnerabilities, there are several tools available in Python. One such tool available in SciCookie is Bandit.</p> <ul> <li>Bandit: It is a tool specifically   designed to identify security issues in Python code. It scans code for common   security problems such as hard-coded passwords and insecure file permissions.   Some of the key features of Bandit are its ease of use, its ability to   integrate with other tools and support for multiple versions of Python. To   learn more about Bandit, you can read its   documentation.</li> </ul> <p>It is important to use code vulnerability detection tools because they can help identify security vulnerabilities in software and fix them before they can be exploited by attackers. This helps to ensure the security and reliability of the project.</p>"},{"location":"guide/#code-coverage-testing","title":"Code coverage testing","text":"<p>Code coverage testing is a software testing method that measures the percentage of code that is executed during a test run. This can be used to identify areas of code that are not being tested and to improve the overall quality of the software.</p> <p>There are a number of different code coverage tools available in Python. In SciCookie you have coverage available.</p> <ul> <li>Coverage: It is an open source tool   for measuring the code coverage of a program. This means that it measures what   percentage of the program code was executed when the tests were run. Coverage   can be useful for identifying parts of the code that are not being tested and   may be vulnerable to bugs. This will show you the percentage of code covered   by your tests, as well as detailed information about which lines were executed   and which were not. If you want to know more about how it works, you can read   the Coverge documentation.</li> </ul> <p>By using code coverage testing in Python, you can ensure that your code has been thoroughly tested and is free of bugs.</p>"},{"location":"guide/#code-style-and-logic-code-quality","title":"Code style and logic (code quality)","text":"<p>Code style refers to the way in which your code is written. It includes things like indentation, line breaks, and variable names. Code logic refers to the way in which your code works. It includes things like the flow of your code, the use of data structures, and the implementation of algorithms.</p> <p>There are a number of tools that can help you to improve the code style and logic of your Python code; analyzing and verification of the code. In SciCookie you can choose and include in your project flake8, Ruff, isort, mccabe, pydocstyle and/or vulture.</p> <ul> <li> <p>Flake8: A tool that helps you find potential   performance issues in your code. Flake8 can detect errors in syntax,   indentation, naming conventions, and other types of style errors. It can be   useful for improving the quality of Python code. Flake8 enforces coding style   conventions defined in the Python Enhancement Proposal 8 (PEP 8).   Additionally, flake8 integrates well with popular code editors like Visual   Studio Code, PyCharm, and Sublime Text. It can highlight style violations   directly in your editor, making it easy to spot and fix issues as you write   code. Flake8 can also be integrated into continuous integration and deployment   (CI/CD) pipelines to ensure code quality standards are met before merging   changes.</p> </li> <li> <p>Ruff: This is an extremely fast Python   linter written in Rust. Linting is the process of inspect code for potential   bugs or style issues, and Ruff is designed to perform this analysis quickly   and efficiently. It is particularly useful for large codebases where   traditional Python linters can be slow and resource intensive.</p> </li> </ul> <p>Ruff is designed to be easy to use and can be integrated into existing Python   development workflows. It can be used as a standalone command line tool, or   integrated into editors and IDEs using plugins or extensions. It is also able   to detect a wide range of potential errors and style issues, and provides   clear and detailed error messages to help developers resolve these issues   quickly.</p> <ul> <li> <p>isort: is a Python utility/library for   automatically sorting imports alphabetically and separating them into sections   and by type. This can help maintain a consistent import style and make the   code easier to read. isort provides a command-line utility, a Python library   and plugins for various editors to quickly sort all your imports. It offers a   number of configuration options to suit each project's import style   preferences, has official pre-commit support and is black-compatible.</p> </li> <li> <p>McCabe:   is a code complexity checker that automatically detects code complexity based   on cyclomatic complexity, which is roughly equal to one plus the number of   loops and if statements. Simply put, it provides an upper bound on the number   of test cases needed to obtain branch coverage of the code. It is recommended   to run it during the git hook pre-commit.</p> </li> <li> <p>Vulture: finds unused code in   Python programs. This is useful for cleaning up and finding bugs in large code   bases. Due to the dynamic nature of Python, static code analysers such as   Vulture are likely to miss some dead code. However, it can be a very useful   tool for improving code quality. It uses static code analysis, it is   self-testing and has full test coverage, it complements pyflakes and has the   same output syntax, it sorts classes and functions by size and it supports   Python &gt;= 3.6, these are some of the main features of Vulture.</p> </li> <li> <p>pydocstyle: is a static analysis   tool for checking compliance with Python docstring conventions. pydocstyle   analyses source code for docstrings and verifies that they comply with the   guidelines set out in PEP 257. This includes rules such as the formatting of   docstrings, the presence of required sections, and the appropriate use of   punctuation and structure. pydocstyle supports Python 3.7 to 3.11 and can be   integrated into development workflows as part of code review or automated   validation processes.</p> </li> </ul> <p>When writing your code, you should always try to make it as clear and concise as possible. This will make it easier for other developers to understand your code and make changes if necessary. It is also important to use data structures and algorithms that are appropriate for the task at hand. This will help ensure that your code is efficient and scalable.</p>"},{"location":"guide/#testing-framework","title":"Testing framework","text":"<p>A test framework is a software tool that provides a set of guidelines, conventions, and utilities for writing and executing automated tests. It provides a structure for organizing tests, and typically includes features for test discovery, test execution, and test reporting.</p> <p>Test frameworks help to ensure the quality of software by automating the testing process. They allow developers to write tests that can be easily executed and repeated, and provide feedback on the success or failure of the tests. There are several options available for developing Python packages. SciCookie supports pytest and hypothesis.</p> <ul> <li> <p>Pytest: It is a popular testing framework   for Python. It simplifies the process of writing and running tests by   providing a concise syntax and powerful features. With Pytest, you can   automatically discover and collect test cases, use fixtures for test setup and   resource management, and write test functions with assert statements to check   expected outcomes. It offers various options for test execution, including   running specific tests, parallel execution, and generating test reports.   Pytest also has a thriving ecosystem of plugins that extend its capabilities,   such as code coverage analysis and test parameterization. Overall, Pytest is   widely adopted for its simplicity, flexibility, and community support, making   it an effective tool for ensuring the quality and reliability of Python code.   You can know more about it in its   documentation.</p> </li> <li> <p>Hypothesis: is a property-based   testing library for Python. It focuses on generating diverse input data and   exploring different scenarios to thoroughly test code. Instead of relying on   specific examples, Hypothesis allows you to define general properties that   your code should satisfy. It automatically generates random inputs, including   edge cases, to uncover potential bugs and unexpected behaviors. Hypothesis   integrates well with popular testing frameworks like Pytest and promotes   comprehensive testing to improve code reliability. If you want to know more,   check out the documentation here.</p> </li> </ul>"},{"location":"guide/#static-analysis-of-shell-scripts","title":"Static analysis of shell scripts","text":"<p>This is the process of analyzing the code of a shell script without actually executing it. This is done by using specialized software tools that can scan the script and identify potential issues such as syntax errors, coding standards violations, security vulnerabilities, and performance problems. In SciCookie you have ShellCheck available.</p> <ul> <li>ShellCheck: This is a static   analysis tool for shell scripts. It checks shell scripts for common errors and   potential bugs, such as syntax errors, variable misuse, and command   substitution issues. Shellcheck supports various shells, including Bash, Dash,   and Zsh, and it can be integrated into various text editors and IDEs. Some   advantages of using Shellcheck may include its ability to catch potential bugs   before they cause issues, its support for multiple shells, and its ease of   integration with various development environments. For more information, you   can visit its website or its repository on   GitHub.</li> </ul> <p>The static analysis of shell scripts is an important tool in your project, it ensure that your code is of high quality, secure, and efficient.</p> <p>Each tool has its own purpose and can be useful in different situations. When choosing among these tools, it's important to consider your specific needs and which tools may be most useful for your project.</p>"},{"location":"guide/#pre-commit-verification","title":"Pre-commit verification","text":"<p>It is a code quality control tool that runs automatically before commits are made to a version control repository. When a commit is made, pre-commit executes the configured hooks. If you select the pre-commit option offered by SciCookie, we have configured the following hooks for you: end-of-file-fixer, black, flake8, ruff, isort, mypy, shellcheck, bandit, pydocstyle, vulture, mccabe and prettier (will be available in your project according to the tools you have selected in TUI).</p> <ul> <li>pre-commit: It is a framework for managing and   maintaining multi-language pre-commit hooks. A list of desired hooks must be   specified, and pre-commit manages the installation and execution of all hooks   written in any language before each commit. You will be notified before the   end of the commit if validation fails, as configured.</li> </ul> <p>This is configured using a <code>.pre-commit-config.yaml</code> file in the repository, which sets the hooks to be executed before each commit. You can check the supported hooks using this link https://pre-commit.com/hooks.html.</p>"},{"location":"guide/#integration-with-devops-tools","title":"Integration with DevOps tools","text":"<p>Integrating your Python project with DevOps tools can bring a number of benefits to the development and deployment process. DevOps tools are designed to automate and streamline the development pipeline, from code development to deployment and maintenance, and can help you improve the speed, quality and reliability of the development process. In SciCookie you can choose between Docker, Podman and Kubernetes. These are all containerization technologies used to deploy and manage applications.</p> <ul> <li> <p>Docker: This is a containerization platform   that allows developers to package their applications and dependencies into a   portable container. Containers are lightweight, efficient, and provide a   consistent runtime environment, making it easier to deploy and run   applications across different environments. In Python projects, Docker can be   used to package and deploy Python applications and dependencies, providing a   consistent runtime environment and making it easier to manage dependencies and   configurations. You can read more about this on the   Docker website and in the   Docker documentation.</p> </li> <li> <p>Podman: It is a container engine without the need   for a daemon running as root. With Podman, you can easily create and run   containers, as well as manage their lifecycle and resources. This integration   improves development and deployment processes, making them more efficient and   streamlined. Podman in Python project helps to achieve a more secure,   efficient and flexible containerization strategy and gives more control over   application dependencies and configurations. As Podman allows containers to be   managed without the need for a daemon, it provides a more secure and   lightweight solution. You can read more about this on the   Podman website and in the   Podman documentation.</p> </li> <li> <p>Kubernetes: It is a container orchestration   platform that automates the deployment, scaling, and management of   containerized applications. It provides a platform for managing and scaling   containerized applications across multiple hosts and environments, and offers   advanced features such as automatic scaling, rolling updates, and   self-healing. In Python projects, Kubernetes can be used to manage and   orchestrate containerized Python applications, providing a scalable and   reliable platform for running and deploying applications. You can read more   about this on the Kubernetes website and in the   Kubernetes documentation.</p> </li> </ul> <p>Overall, Docker, Podman, and Kubernetes are powerful tools for managing and deploying containerized applications, and can provide a streamlined and efficient platform for running Python projects.</p> <p>In case you do not want to include DevOps in your project, you can do so by selecting the option <code>None</code> (this is the default option).</p>"},{"location":"guide/#automation-tools","title":"Automation tools","text":"<p>An automation tool is software or a platform designed to automate repetitive tasks, processes, or workflows that are traditionally performed manually. These tools are used to streamline and optimize various operations, reduce human intervention, increase efficiency, and minimize errors. Currently, SciCookie allows you to use <code>Make</code> and/or <code>Makim</code>.</p> <ul> <li> <p>Makim: Makim is an innovative tool   inspired by make, designed to simplify target and dependency definition   through YAML format. It introduces advanced features such as conditionals,   arguments, and dependencies with targeted parameters. It also facilitates   organized grouping of targets and supports user-defined variables and   environment variables. Makim empowers users to streamline documentation and   parameterize targets effectively. This free and open-source tool offers   improved target management while maintaining compatibility with familiar YAML   syntax.</p> </li> <li> <p>Make: Make is a versatile   build automation tool that uses Makefiles to define rules and dependencies for   compiling code and building projects. It automates the process, intelligently   rebuilding only changed components, streamlining software development   workflows.</p> </li> </ul>"},{"location":"guide/#project-team","title":"Project team","text":"<p>The project team refers to the group of people responsible for developing and maintaining the project. This includes developers, designers, testers and other stakeholders involved in the project. It is important that they are governed by some rules and regulations so that they become a friendly group with standards that others can follow and form a wider community. In SciCookie, we have some options that are linked to the code of conduct, the governance document and the roadmap.</p>"},{"location":"guide/#code-of-conduct","title":"Code of conduct","text":"<p>A code of conduct is a set of guidelines that outlines the expected behavior of individuals participating in a community or organization. It typically specifies the types of behavior that are considered acceptable and unacceptable, as well as the consequences for violating the code of conduct. In SciCookie you can find and choose between three adaptations of well-known codes of conduct accepted by a large part of the community: A Code of Conduct for Open Source Communities by Contributors Covenant,The Citizen Code of Conduct,and an adapted version of the NumFOCUS and Python Codes of Conduct.</p> <ul> <li> <p><code>contributor-covenant</code> option: The Contributor Covenant aims to create a   safe and inclusive environment for all contributors to open source projects.   By promoting inclusive language, respectful communication, and a   zero-tolerance policy for harassment and discrimination, it helps to ensure   that everyone can participate in open source communities without fear of   discrimination or mistreatment. If you want to know more about this, you can   visit the full text of this   code of conduct.</p> </li> <li> <p><code>citizen-code-of-conduct</code> option: The Citizen Code of Conduct is intended   to create a safe and welcoming environment for all members of the community.   By promoting respectful communication, inclusive behavior, and collaboration,   it helps to ensure that everyone can participate in the community without fear   of discrimination or mistreatment. If you would like to know more, you can   read the full text of this   code of conduct.</p> </li> <li> <p><code>numfocus-adapted-coc</code> option: It is an adaptation of the NumFocus Code of   Conduct, promotes kindness, respect, professionalism, good communication,   among others. It does not tolerate harassment, regardless of gender, sexual   orientation, gender identity and expression, disability, physical appearance,   body size, race or religion of the members; nor sexist, racist or exclusionary   jokes. If you wish to read the full text, please visit this link   code of conduct</p> </li> <li> <p><code>python-adapted-coc</code> option: This option is an adaptation of the Python   Code of Conduct prioritizing inclusivity, respect, and a welcoming community.   It emphasizes kindness, discourages discrimination, and encourages positive   contributions, consideration, and collaboration among all members. If you   would like to know more, you can read the full text of this   code of conduct.</p> </li> </ul> <p>In case you do not want to include this file in your project, you can do so by selecting the option <code>None</code> (this is the default option).</p>"},{"location":"guide/#governance-document","title":"Governance document","text":"<p>A governance document is a formal document that outlines the structure, policies, and procedures of an organization or community. It typically describes how decisions are made, how resources are allocated, and how conflicts are resolved. This can take many different forms, depending on the needs and goals of the organization or community. SciCookie offers two adaptations for your project governance document: NumPy Governance and SciML Scientific Machine Learning Governance.</p> <ul> <li> <p><code>numpy-governance</code> option: NumPy is a widely used open source project for   scientific computing in Python. Its governance document outlines how the   project is managed and how decisions are made.   The NumPy governance document   describes the roles and responsibilities of the project's contributors,   maintainers, and steering council, as well as the decision-making processes   and procedures for contributing to the project. It emphasizes the importance   of transparency, inclusivity, and participation in the development of the   project. The NumPy Governance Document provides a clear framework for the   management of the project and helps to ensure that it remains a vibrant and   sustainable community-driven project. If you want to read the full text of   Numpy's governance document, click   here.</p> </li> <li> <p><code>sciml-governance</code> option:   SciML Scientific Machine Learning Governance   is a governance document that outlines the structure and decision-making   processes of the SciML community, which focuses on the development of   scientific machine learning tools and methods. The document describes the   roles and responsibilities of community members, including the Steering   Committee and Technical Leaders. It also outlines the community's   decision-making processes, including how new projects are proposed and   accepted, and how conflicts and disputes are handled. The governance document   emphasizes the importance of collaboration, inclusivity and transparency in   the development of scientific machine learning tools and methods. It also   provides a clear framework for the governance of the community, helping to   ensure that it remains a vibrant and effective force in the development of   scientific machine learning. If you want to read the full text of SciML   Scientific Machine Learning Governance, click   here.</p> </li> </ul> <p>In case you do not want to include this file in your project, you can do so by selecting the option <code>None</code> (this is the default option).</p>"},{"location":"guide/#roadmap-document","title":"Roadmap document","text":"<p>A roadmap is a strategic plan that outlines the objectives, milestones and actions required to achieve a specific goal or vision. It is typically used in business, project management and product development to provide a high-level overview of the steps required to achieve a desired outcome. A roadmap can include timelines, budgets, resource requirements and key performance indicators to track progress and measure success. The purpose is to provide a clear and actionable plan for achieving a goal and to communicate that plan to stakeholders and team members. SciCookie offers an adaptation for your project roadmap document: PyTorch-Ignite roadmap.</p> <ul> <li><code>pytorch-ignite-roadmap</code> option: PyTorch Ignite is an open-source library   for high-level training and evaluation of neural networks in PyTorch. The   PyTorch Ignite roadmap outlines the development plans for the library,   including new features, bug fixes, and performance improvements. The roadmap   may include timelines for releasing new versions, as well as details on   specific features that are planned for each release. If you want to read the   full text of PyTorch Ignite Roadmap, click   here.</li> </ul> <p>In case you do not want to include this file in your project, you can do so by selecting the option <code>None</code> (this is the default option).</p>"},{"location":"guide/#version-control","title":"Version control","text":"<p>Version control is essential for any project because it enables us to track and store all versions and changes made to our codebase. With this in mind, we have added some functionalities to SciCookie that allow you to easily add your Git account information and project URLs.</p> <p>By filling in the following fields, you can integrate your codebase with Git and take advantage of its powerful version control features:</p> <p>git_username: This is where you can enter your Git username, which will be used only in the text of the documentation.</p> <p>git_https_origin: This is the Git https origin URL, which is used for configuring your repository in your local environment.</p> <p>git_https_upstream: This is the Git https upstream URL, which is used for adding on text of documentation installation and the contributing file, as well as configuring your repository in your local environment.</p> <p>git_main_branch: This field allows you to specify the name of your main branch. By default, it is named \"main\".</p> <p>By providing this information, you can easily integrate your codebase with GitHub and take advantage of its powerful version control features. These functionalities in SciCookie make it easy to manage your project and collaborate with others, while ensuring that your code is properly versioned and tracked.</p>"}]}